<html>
  <head>
    <title>c3p0-v@c3p0.version@ - JDBC3 Connection and Statement Pooling - Documentation</title>
    <style type="text/css">
      a.cfg_param {
         font-family: monospace;
      }
      body {
         font-family: optima, helvetica, arial, sans-serif;
      }
      dl.properties {
         padding: 0em 3em 0em 3em;
      }
      dl.properties dd {
         padding-bottom: 0.5em;
         font-size: smaller;
      }
      dl.properties dt {
         padding-top: 1em;
         border-top: 1 dashed black;
         font-family: monospace;
	 color: red;
      }
      dl.properties div.default {
         padding-top: 0.5em;
         text-decoration: underline;
         padding-bottom: 0.5em;
      }
      div.example {
         white-space: pre;
         font-family: monospace;
	 font-size: smaller;
	 background-color: #CCCCFF;
         margin: 3em 3em 3em 3em;
         padding: 1em 0em 1em 2em;
         border-top: 2 solid black;
         border-bottom: 2 solid black;
      }
      div.example_properties {
         white-space: pre;
         font-family: monospace;
	 font-size: smaller;
	 background-color: #CCCCFF;
         margin: 3em 3em 3em 3em;
         padding: 1em 0em 1em 0em;
         border-top: 2 solid black;
         border-bottom: 2 solid black;
      }
      div.example_properties strong {
         font-weight: bold;
	 color: red;
      }
      div.sectiontext {
         margin-left: 1em;
      }
      div.subtitle {
	 font-size: 12pt;
	 background-color: #FFFFFF;
      }
      div.top_boilerplate {
         margin-left: 8em;
         margin-right: 8em;
      }

      h1 {
         text-align: center;
	 background-color: #FFCCAA;
      }
      h2 {
	 background-color: #FFFFAA;
         border-bottom: 2 solid black;
         margin-top: 2em;
      }
      ol.contents ol {
         list-style-type: lower-roman;
      }
      ol.contents ol li {
	 font-size: smaller;
      }
      ul.pointerlist {
         list-style: square;
      }

    </style>
  </head>
  <body>
    <h1>
      <div>c3p0 - JDBC3 Connection and Statement Pooling</div>
      <div class="subtitle">version @c3p0.version@</div>
    </h1>
    <div class="top_boilerplate">
      <p>by Steve Waldman &lt;<a href="mailto:swaldman@mchange.com">swaldman@mchange.com</a>&gt;</p>
      <p>&copy; 2004 Machinery For Change, Inc.</p>
      <p><i>
	  This software is made available for use, modification, and redistribution,
	  under the terms of the <a href="../LICENSE">Lesser GNU Public License (LGPL)</a>, which you should
	  have received with this distribution.
      </i></p>
      <ul class="pointerlist"> 
	<li>API docs for c3p0 are <a href="apidocs/index.html">here</a>.</li> 
	<li>Download the latest version from <a href="http://sourceforge.net/projects/c3p0/">c3p0's site on SourceForge</li>
      </ul>
    </div>
    <hr/>
    <h2><a name="contents">Contents</a></h2>
    <ol class="contents">
      <li><a href="#contents">Contents</a></li>
      <li><a href="#quickstart">Quickstart</a></li>
      <li><a href="#what_is">What is c3p0?</a></li>
      <li><a href="#prerequisites">Prerequisites</a></li>
      <li><a href="#installation">Installation</a></li>
      <li>
	<a href="#using_c3p0">Using c3p0</a>
	<ol>
	  <li><a href="#using_combopooleddatasource">Using ComboPooledDataSource</a></li>
	  <li><a href="#using_datasources_factory">Using the DataSouces factory class</a></li>
	  <li><a href="#querying">Querying Pool Status</a></li>
	  <li><a href="#cleaning">Cleaning Up Pool Resources</a></li>
	  <li><a href="#build_your_own">Advanced: Building Your Own PoolBackedDataSource</a></li>
	  <li><a href="#raw_connection_ops">Advanced: Raw Connection Operations</a></li>
	</ol>
      </li>
      <li>
	<a href="#configuration">Configuration</a>
	<ol>
	  <li><a href="#c3p0_properties">Overriding c3p0 defaults with a c3p0.properties file</a></li>
	  <li><a href="#programmatic_configuration">Programmatic configuration of DataSources</a></li>
	  <li><a href="#configuring_connection_testing">Configuring Connection Testing</a></li>
	  <li><a href="#configuring_statement_pooling">Configuring Statement Pooling</a></li>
	</ol>
      </li>
      <li><a href="#known_shortcomings">Performance</a></li>
      <li><a href="#known_shortcomings">Known shortcomings</a></li>
      <li><a href="#feedback_and_support">Feedback and support</a></li>
      <li><a href="#appendix_a">Appendix A: Configuration Properties</a></li>
      <li><a href="#appendix_b">Appendix B: Configuring c3p0 pooled DataSources for Apache Tomcat</a></li>
      <li><a href="#appendix_c">Appendix C: Oracle-specific API: createTemporaryBLOB() and createTemporaryCLOB()</a></li>
    </ol>
      (See also the API Documentation <a href="apidocs/index.html">here</a>)
    <hr/>
    <h2><a name="quickstart">Quickstart</a></h2>
    <div class="sectiontext">
      <p>
	c3p0 was designed to be butt-simple to use. Just put
	the jar file [<tt>lib/c3p0-@c3p0.version@.jar</tt>] in your applications
	effective <tt>CLASSPATH</tt>, and make a <tt>DataSource</tt> like this:
      </p>
      <div class="example">
import com.mchange.v2.c3p0.*;
	
...
	
ComboPooledDataSource cpds = new ComboPooledDataSource();
cpds.setDriverClass( "org.postgresql.Driver" ); //loads the jdbc driver            
cpds.setJdbcUrl( "jdbc:postgresql://localhost/testdb" );
cpds.setUser("dbuser");                                  
cpds.setPassword("dbpassword");                                  
      </div>
      <p>
	<b>[Optional]</b> If you want to turn on PreparedStatement pooling, you must also set <tt>maxStatements</tt> 
	and/or <tt>maxStatementsPerConnection</tt>(both default to 0):
      </p>
      <div class="example">
cpds.setMaxStatements( 180 );                                  
      </div>
      <p>
	Do whatever you want with your <tt>DataSource</tt>, which will be backed
	by a <tt>Connection</tt> pool set up with default parameters. You
	can bind the <tt>DataSource</tt> to a JNDI name service, or use it
	directly, as you prefer.
      </p>
      <p>
	When you are done, you can clean up the <tt>DataSource</tt> you've created
	like this:
      </p>
      <div class="example">
DataSources.destroy( cpds );
      </div>
      <p>
	That's it! The rest is detail.
      </p>
    </div>
    <h2><a name="basics">What is c3p0?</a></h2>
    <div class="sectiontext">
      <p>
	c3p0 is an easy-to-use library for making traditional JDBC drivers 
	"enterprise-ready" by augmenting them with functionality defined by 
	the jdbc3 spec and the optional extensions to jdbc2. In particular, 
	c3p0 provides several useful services:
      </p>
      <ul>
	<li>
	  Classes which adapt traditional DriverManager-based JDBC
	  drivers to the new <tt>javax.sql.DataSource</tt> scheme for acquiring
	  database <tt>Connection</tt>s.
	</li>
	<li>
	  Transparent pooling of <tt>Connection</tt> and <tt>PreparedStatement</tt>s
	  behind <tt>DataSource</tt>s which can "wrap" around traditional
	  drivers or arbitrary unpooled <tt>DataSource</tt>s.
	</li>
      </ul>
      <p>
	The library tries hard to get the details right:
      </p>
      <ul>
	<li>
	  c3p0 <tt>DataSource</tt>s are both <tt>Referenceable</tt> and <tt>Serializable</tt>, and are thus
	  suitable for binding to a wide-variety of JNDI-based naming services.
	</li>
	<li>
	  <tt>Statement</tt> and <tt>ResultSet</tt>s are carefully cleaned up when pooled
	  <tt>Connection</tt>s and <tt>Statement</tt>s are checked in, to prevent resource-
	  exhaustion when clients use the lazy but common resource-management
	  strategy of only cleaning up their <tt>Connection</tt>s....
	</li>
	<li>
	  The library adopts the approach and uses the internal interfaces
	  defined by the JDBC 2 and 3 specification (even where these
	  conflict with the library author's preferences). <tt>DataSource</tt>s
	  are written in the JavaBean style, offering all the required and
	  most of the optional properties (as well as some non-standard ones),
	  and no-arg constructors.
	</li>
      </ul>
      <p>
	c3p0 hopes to provide <tt>DataSource</tt> implementations more than suitable for 
	use by high-volume "J2EE enterprise applications". Please provide feedback, bug-fixes, etc.!
      </p>
    </div>
    <h2><a name="prerequisites">Prerequisites</a></h2>
    <div class="sectiontext">
      <p>
	c3p0 requires a level 1.3.x or above Java Runtime Environment, and
	the JDBC 2.x or above javax.sql libraries. c3p0 works fine under
	Java 1.4.x.
      </p>
    </div>
    <h2><a name="installation">Installation</a></h2>
    <div class="sectiontext">
      <p>
	Put the file <tt>lib/c3p0-0.8.x.jar</tt> required libraries
	somewhere in your CLASSPATH (or any other place where your application's
	classloader will find it). That's it!
      </p>
    </div>
    <h2><a name="using c3p0">Using c3p0</a></h2>
    <div class="sectiontext">
      <p>
	From a users' perspective, c3p0 simply provides standard jdbc2 <tt>DataSource</tt>
	objects. When creating these <tt>DataSource</tt>s, users can control pooling-related, 
	naming-related, and other properties (See <a href="#appendix_a">Appendix A</a>). All pooling is entirely
	transparent to users once a <tt>DataSource</tt> has been created.
      </p>
      <p>
	There are three ways of acquiring c3p0 pool-backed <tt>DataSource</tt>s: 1) directly instantiate and configure a 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a> bean; 
	2) use the <tt>DataSource</tt>s factory class; or 3) "build your own" pool-backed
	<tt>DataSource</tt> by directly instantiating <tt>PoolBackedDataSource</tt> and setting its <tt>ConectionPoolDataSource</tt>. Most
	users will probably find instantiating <a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a>
	to be the most convenient approach. Once instantiated,
	c3p0 <tt>DataSource</tt>s can be bound to nearly any JNDI-compliant name service.
      </p>
      <p>
	Regardless of how you create your <tt>DataSource</tt>, c3p0 will use defaults for any configuration parameters that
	you do not specify programmatically. c3p0 has built-in, hard-coded defaults, but you can override these by creating
	a file called <tt>c3p0.properties</tt> and storing it as a top-level resource in the same <tt>CLASSPATH</tt> / classloader
	that loads c3p0's jar file. (See <a href="#configuration">Configuration</a> below.)
      </p>
      <a name="using_combopooleddatasource">
	<h3>Instantiating and Configuring a ComboPooledDataSource</h3>
      </a>
      <p>
	Perhaps the most straightforward way to create a c3p0 pooling <tt>DataSource</tt> is to instantiate an instance of 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>com.mchange.v2.c3p0.ComboPooledDataSource</tt></a>. 
	This is a JavaBean-style class with a public, no-arg constructor,
	but before you use the <tt>DataSource</tt>, you'll have to be sure to set at least the property <tt>jdbcUrl</tt>. You may also
	want to set <tt>user</tt> and <tt>password</tt>, and if you have not externally preloaded the old-style JDBC driver you'll
	use you should set the <tt>driverClass</tt>.
      </p>
      <div class="example">
ComboPooledDataSource cpds = new ComboPooledDataSource();
cpds.setDriverClass( "org.postgresql.Driver" ); //loads the jdbc driver            
cpds.setJdbcUrl( "jdbc:postgresql://localhost/testdb" );
cpds.setUser("swaldman");                                  
cpds.setPassword("test-password");                                  
	
// the settings below are optional -- c3p0 can work with defaults
cpds.setMinPoolSize(5);                                     
cpds.setAcquireIncrement(5);
cpds.setMaxPoolSize(20);
	
// The DataSource cpds is now a fully configured and usable pooled DataSource
	
...
      </div>
      <a name="using_datasources_factory">
	<h3>Using the DataSources factory class</h3>
      </a>
      <p>
	Alternatively, you can use the static factory class 
	<a href="apidocs/com/mchange/v2/c3p0/DataSources.html"><tt>com.mchange.v2.c3p0.DataSources</tt></a> to build unpooled <tt>DataSource</tt>s 
	from traditional JDBC drivers, and to build pooled <tt>DataSource</tt>s from unpooled <tt>DataSource</tt>s:
      </p>
      <div class="example">
DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                        "swaldman", 
                                                        "test-password");
DataSource ds_pooled = DataSources.pooledDataSource( ds_unpooled );

// The DataSource ds_pooled is now a fully configured and usable pooled DataSource.
// The DataSource is using a default pool configuration, and Postgres' JDBC driver
// is presumed to have already been loaded via the jdbc.drivers system property or an
// explicit call to Class.forName("org.postgresql.Driver") elsewhere.
	
...
      </div>
      <p>
	If you use the <a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>
	factory class, and you want to programmatically override default configuration
	parameters, make use of the <a href="apidocs/com/mchange/v2/c3p0/PoolConfig.html"><tt>PoolConfig</tt></a> class:
      </p>
      <div class="example">
DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                        "swaldman", 
                                                        "test-password");
							      
PoolConfig pc = new PoolConfig();
pc.setMaxStatements(200);  //turn on Statement pooling

// pass our overriding PoolConfig to the DataSources.pooledDataSource() factory method.

ds_pooled = DataSources.pooledDataSource( ds_unpooled, pc ); 

// The DataSource ds_pooled is now a fully configured and usable pooled DataSource,
// with Statement caching enabled for a maximum of up to 200 statements.

...
      </div>
      <a name="querying">
	<h3>Querying a PooledDataSource's current status</h3>
      </a>
      <p>
	c3p0 <tt>DataSource</tt>s backed by a pool, which include implementations of 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a> and
	the objects returned by <tt><a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.pooledDataSource( ... )</tt>, 
	all implement the interface
	<a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>com.mchange.v2.c3p0.PooledDataSource</tt></a>, 
	which makes available a number of methods for querying the status of
	<tt>DataSource Connection</tt> pools. Below is sample code that queries a <tt>DataSource</tt> for its 
	status:
      </p>
      <div class="example">
// fetch a JNDI-bound DataSource
InitialContext ictx = new InitialContext();
DataSource ds = (DataSource) ictx.lookup( "java:comp/env/jdbc/myDataSource" );

// make sure it's a c3p0 PooledDataSource
if ( ds instanceof PooledDataSource)
{
  PooledDataSource pds = (PooledDataSource) ds;
  System.err.println("num_connections: "      + pds.getNumConnections());
  System.err.println("num_busy_connections: " + pds.getNumBusyConnections());
  System.err.println("num_idle_connections: " + pds.getNumIdleConnections());
  System.err.println();
}
else
  System.err.println("Not a c3p0 PooledDataSource!");
      </div>
      <p>
	The status querying methods all come in two overloaded forms, such as:
      </p>
      <ul>
	<li><tt>public int getNumConnections()</tt></li>
	<li><tt>public int getNumConnections(String username, String password)</tt></li>
      </ul>
      <p>
	The version with arguments is necessary in case clients have retrieved <tt>Connection</tt>s from
	the <tt>DataSource</tt> using an explicit username and password 
	[i.e. by calling <tt>myDataSource.getConnection("myname", "mypassword")</tt>] 
	rather than using the <tt>DataSource</tt>'s default authentication, which is defined by the JavaBean properties
	<tt>user</tt> and <tt>password</tt>, and used in calls to <tt>myDataSource.getConnection()</tt> with no arguments. 
	c3p0 maintains separate pools for Connections with distinct
	authentications, and you can query the status of those pools individually. 
      </p>
      <p>
	<i>
	  Most users acquire default-authenticated Connections from <tt>DataSource</tt>s, and
	  and can thus rely on the default, no-arg versions of the status-querying methods.
	</i>
      </p>
      <a name="cleaning">
	<h3>Cleaning up after c3p0 PooledDataSources</h3>
      </a>
      <p>
	The easy way to clean up after c3p0-created <tt>DataSource</tt>s is to use the static destroy method
	defined by the class <a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>. Only 
	<a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>s 
	need to be cleaned up, but 
	<a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.destroy( ... ) does no harm if it is called on an unpooled or non-c3p0
	DataSource.
      </p>
      <div class="example">
DataSource ds_pooled   = null;
	
try
{
  DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                          "swaldman", 
                                                          "test-password");
  ds_pooled = DataSources.pooledDataSource( ds_unpooled );

  // do all kinds of stuff with that sweet pooled DataSource...
}
finally
{
  DataSources.destroy( ds_pooled );
}
      </div>
      <p>
	Alternatively, c3p0's <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	interface contains a <tt>close()</tt> method
	that you can call when you know you are finished with a DataSource. So, you can cast a c3p0
	derived <tt>DataSource</tt> to a <tt>PooledDataSource</tt> and close it:
      </p>
      <div class="example">
static void cleanup(DataSource ds) throws SQLException
{
  // make sure it's a c3p0 PooledDataSource
  if ( ds instanceof PooledDataSource)
  {
    PooledDataSource pds = (PooledDataSource) ds;
    pds.close();
  }     
  else
    System.err.println("Not a c3p0 PooledDataSource!");
}
      </div>
      <p>
	Regardless of which method you use, closing or destroying a <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	does not necessarily shut down the underlying pools. It is possible for several 
	<tt>DataSource</tt> instances to share the same <tt>Connection</tt> and <tt>Statement</tt> pools. Calling
	<tt>close()</tt> or <tt>destroy()</tt> decrements a reference count, and the pools are actually
	shut down only when the reference count goes to zero. If you are careful to close()
	all your <tt>DataSource</tt> instances, you can reliably clean up all of c3p0's pooled 
	<tt>Connection</tt>s and helper threads.
      </p>
      <p>
	Unreferenced instances of <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	that are not <tt>close()</tt>ed by clients
	<tt>close()</tt> themselves prior to garbage collection in their <tt>finalize()</tt> methods. 
	As always, finalization should be considered
	a backstop and not a prompt or sure approach to resource cleanup.
      </p>
      <a name="build_your_own">
	<h3>Advanced: Building your own PoolBackedDataSource</h3>
      </a>
      <p>
	There is little reason for most programmers to do this, but you can build a pooling <tt>DataSource</tt> in a
	step-by-step way by instantiating and configuring an unpooled <tt>DriverManagerDataSource</tt>, instantiating a
	<tt>WrapperConnectionPoolDataSource</tt> and setting the unpooled <tt>DataSource</tt> as its <tt>nestedDataSource</tt> property,
	and then using that to set the <tt>connectionPoolDataSource</tt> property of a new <tt>PoolBackedDataSource</tt>.
      </p>
      <p>
	This sequence of events is primarily interesting if your driver offers an unpooled implementation of DataSource, and you'd
	like c3p0 to use that. Rather than using c3p0's <tt>DriverManagerDataSource</tt> implementation, you can substitute your
	vendor-supplied <tt>DataSource</tt> as the <tt>nestedDataSource</tt> for a <tt>WrapperConnectionPoolDataSource</tt>.
      </p>
      <a name="raw_connection_ops">
	<h3>Advanced: Raw Connection Operations</h3>
      </a>
      <p>
	JDBC drivers sometimes define vendor-specific, non-standard API on Connection implementations. C3P0 wraps
	Connections behind a proxy, so you cannot cast C3P0-returned Connections to the vendor-specific implementation
	class. C3P0 does not provide any means of accessing the raw Connection directly, because C3P0 needs to keep
	track of Statements and ResultSets returned by the Connection in order to prevent resource leaks and pool
	corruption.
      </p>
      <p>
	C3P0 does provide an API that allows you to invoke non-standard methods reflectively on the underlying
	Connection. To use it, first cast the returned Connection to a 
	<a href="apidocs/com/mchange/v2/c3p0/C3P0ProxyConnection.html"><tt>C3P0ProxyConnection</tt></a>. Then call
	the method <tt>rawConnectionOperation</tt>, supplying the <tt>java.lang.reflect.Method</tt> object for
	the non-standard method you wish to call as an argument. The <tt>Method</tt> you supply will be invoked
	on the target you provide on the second argument (null for static methods), and using the arguments you
	supply in the third argument to that function. For the target, and for any of the method arguments, you
	can supply the special token <tt>C3P0ProxyConnection.RAW_CONNECTION</tt>, which will be replaced with
	the underlying vendor-specific <tt>Connection</tt> object before the <tt>Method</tt> is invoked.
      </p>
      <p>
	Any Statements (including Prepared and CallableStatements) and ResultSets returned by the operation
	will be c3p0-managed, and will be properly cleaned-up on <tt>close()</tt> of the parent proxy Connection.
	Users must take care to clean up any non-standard resources returned by a vendor-specific method.
      </p>
      <p>
	Here's an example of using Oracle-specific API to call a static method on a raw Connection:
      </p>
      <div class="example">

C3P0ProxyConnection castCon = (C3P0ProxyConnection) c3p0DataSource.getConnection();
Method m = CLOB.class.getMethod("createTemporary", new Class[]{Connection.class, boolean.class, int.class});
Object[] args = new Object[] {C3P0ProxyConnection.RAW_CONNECTION, Boolean.valueOf( true ), new Integer( 10 )};
CLOB oracleCLOB = (CLOB) castCon.rawConnectionOperation(m, null, args);			
      </div>
      <p>
	<i>Note: C3P0 now includes special support for some Oracle-specific methods. 
           See <a href="#appendix_c">Appendix C</a>.
        </i>
      </p>
      <h2><a name="configuration">Configuration</a></h2>
      <p>
	While c3p0 does not <i>require</i> very much configuration, it is very tweakable. All the interesting
	knobs and dials are represented as JavaBean properties. Following JavaBean conventions, we note that
	if an Object has a property of type <tt>T</tt> called <tt>foo</tt>, it will have methods that look
	like...
	<blockquote><tt>
	    public T getFoo();<br/>
	    public void setFoo(T foo);
	</tt></blockquote>
	...or both, depending upon whether the property is read-only, write-only, or read-writable.
      </p>
      <p>
	The tweakable properties, along with their definitions and default values, are described 
	in <a href="#appendix_a">Appendix A</a> below.
      </p>
      <p>
	There are two ways to modify c3p0 properties: You can override the defaults for your
	entire application, or you can programmatically alter the values associated with a
	particular <tt>DataSource</tt>.
      </p>
      <a name="c3p0_properties">
	<h3>Overriding c3p0 defaults via <tt>c3p0.properties</tt></h3>
      </a>
      <p>
	To override the library's built-in defaults, create a file called <tt>c3p0.properties</tt>
	and place it at the "root" of your classpath or classloader. For a typical standalone
	application, that means place the file in a directory named in your <tt>CLASSPATH</tt>
	environment variable. For a typical web-application, the file should be placed in 
	<tt>WEB-INF/classes</tt>. In general, the file must be available as a classloader
	resource under the name <tt>/c3p0.properties</tt>, in the classloader that loaded
	c3p0's jar file. Review the API docs (especilly <tt>getResource...</tt> methods) of 
	<tt>java.lang.Class</tt>, <tt>java.lang.ClassLoader</tt>, and <tt>java.util.ResourceBundle</tt> 
	if this is unfamiliar.
      </p>
      <p>
	The format of <tt>c3p0.properties</tt> should be a normal Java Properties file format,
	whose keys are c3p0 configurable properties. See <a href="#appendix_a">Appendix A</a>.
	for the specifics. An example <tt>c3p0.properties</tt> file is produced below:
      </p>
      <div class="example">
# turn on statement pooling
c3p0.maxStatements=150
	
# close pooled Connections that go unused for
# more than half an hour
c3p0.maxIdleTime=1800
      </div>
      <a name="programmatic_configuration">
	<h3>Programmatic configuration of <tt>DataSource</tt> instances</h3>
      </a>
      <p>
	<tt>DataSource</tt>s are usually configured before they are used, either
	during or immediately following their construction. c3p0 does
	support property modifications midstream, however.
      </p>
      <p>
	If you obtain a <tt>DataSource</tt> by instantiating a 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a>, 
	configure it by simply calling appropriate setter methods offered by that class
	before attempting a call to <tt>getConnection()</tt>. See the example above.
      </p>
      <p>
	If you obtain a <tt>DataSource</tt> by using factory methods of
	the utility class <a href="apidocs/com/mchange/v2/c3p0/DataSources.html"><tt>com.mchange.v2.c3p0.DataSources</tt></a>,
	and wish to use a non-default configuration,
	you should first create a <a href="apidocs/com/mchange/v2/c3p0/PoolConfig.html"><tt>PoolConfig</tt></a> Object,
	call the appropriate property setters on that <a href="apidocs/com/mchange/v2/c3p0/PoolConfig.html"><tt>PoolConfig</tt></a>,
	and pass your configuration as an argument to 
	<tt><a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.pooledDataSource( ... )</tt>.
	See the example above.
      </p>
      <a name="configuring_connection_testing">
	<h3>Configuring Connection Testing</h3>
      </a>
      <p>
	c3p0 can be configured to test the <tt>Connection</tt>s that it pools in a variety of ways, to
	minimize the likelihood that your application will see a broken or "stale" <tt>Connection</tt>.
	Pooled <tt>Connection</tt>s can go bad for a variety of reasons -- some JDBC drivers intentionally
	"time-out" long-lasting database Connections; back-end databases or networks sometimes go down 
	"stranding" pooled Connections; and Connections can simply become corrupted over time and use due
	to resource leaks, driver bugs, or other causes.
      </p>
      <p>
	c3p0 provides users a great deal of flexibility in testing Connections, via the following
	configuration parameters:
      </p>
      <ul>
	<li><a class="cfg_param" href="#automaticTestTable">automaticTestTable</a></li>
	<li><a class="cfg_param" href="#connectionTesterClassName">connectionTesterClassName</a></li>
	<li><a class="cfg_param" href="#preferredTestQuery">preferredTestQuery</a></li>
	<li><a class="cfg_param" href="#testConnectionOnCheckin">testConnectionOnCheckin</a></li>
	<li><a class="cfg_param" href="#testConnectionOnCheckout">testConnectionOnCheckout</a></li>
	<li><a class="cfg_param" href="#idleConnectionTestPeriod">idleConnectionTestPeriod</a></li>
      </ul>
      <p>
	<tt>idleConnectionTestPeriod</tt>, <tt>testConnectionOnCheckout</tt>, and
	<tt>testConnectionOnCheckin</tt> control <i>when</i> <tt>Connection</tt>s will be tested.
	<tt>automaticTestTable</tt>, <tt>connectionTesterClassName</tt>, and <tt>preferredTestQuery</tt> control <i>how</i>.
      </p>
      <p>
	When configuring
	<tt>Connection</tt> testing, first try to minimize the cost of each test. By default, <tt>Connection</tt>s are tested
	by calling the <tt>getTables()</tt> method on a <tt>Connection</tt>'s associated <tt>DatabaseMetaData</tt>
	object. This has the advantage of working with any database, independent of database schema. However, empirical
	a <tt>DatabaseMetaData.getTables()</tt> call is often much slower than a simple database query.
      </p>
      <p>
	The most convenient way to speed up <tt>Connection</tt> testing is to define the parameter <tt>automaticTestTable</tt>. Using the name
	you provide, c3p0 will create an empty table, and make a simple query against it to test the database. Alternatively, if your 
	database schema
	is fixed prior to your application's use of the database, you can simply define a test query with the <tt>preferredTestQuery</tt>
	parameter. Be careful, however. Setting <tt>preferredTestQuery</tt> will lead to errors as <tt>Connection</tt> tests fail
	if the query target table does not exist in your database table <u>prior</u> to initialization of your DataSource. (Advanced
	users may define any kind of <tt>Connection</tt> testing they wish, by implementing the interface 
	<a href="apidocs/com/mchange/v2/c3p0/ConnectionTester.html">ConnectionTester</a> or 
	<a href="apidocs/com/mchange/v2/c3p0/advanced/QueryConnectionTester.html">QueryConnectionTester</a>, and supplying the
	fully qualified name of the class as <tt>connectionTesterClassName</tt>.)
      </p>
      <p>
	The most reliable time to test <tt>Connection</tt>s is on check-out. But this is also the most costly choice
	from a performance perspective. Most applications should work quite reliably using a combination of 
	<tt>idleConnectionTestPeriod</tt> and <tt>testConnectionsOnCheckIn</tt>. Both the idle test and the check-in 
	test are performed asynchronously, which leads to better performance, both perceived and actual.
      </p>
      <p>
	Note that for many applications, high performance is more important than the risk of an occasional database exception.
	In its default configuration, c3p0 does no Connection testing at all. Setting a long 
	<tt>idleConnectionTestPeriod</tt>, and not testing on checkout and check-in at all is an excellent, high-performance
	approach.
      </p>
      <a name="configuring_statement_pooling">
	<h3>Configuring Statement Pooling</h3>
      </a>
      <p>
	c3p0 implement's transparent <tt>PreparedStatement</tt> pooling as defined by the JDBC spec. Under some circumstances,
	statement pooling can dramatically improve application performance. Under other circumstances, the overhead of
	statement pooling can slightly harm
	performance. Whether and how much statement pooling will help depends on how much 
	parsing, planning, and optimizing of queries your databases does when the statements are prepared. 
	Databases (and JDBC drivers) vary widely
	in this respect. It's a good idea to benchmark your application with and without statement pooling to 
	see if and how much it helps.
      </p>
      <p>
	You configure statement pooling in c3p0 via the following
	configuration parameters:
      </p>
      <ul>
	<li><a class="cfg_param" href="#maxStatements">maxStatements</a></li>
	<li><a class="cfg_param" href="#maxStatementsPerConnection">maxStatementsPerConnection</a></li>
      </ul>
      <p>
	<tt>maxStatements</tt> is JDBC's standard parameter for controlling statement pooling. <tt>maxStatements</tt> defines the
	total number <tt>PreparedStatements</tt> a DataSource will cache. The pool will destroy the least-recently-used <tt>PreparedStatement</tt>
	when it hits this limit. This sounds simple, but it's actually a strange approach, because
	cached statements conceptually belong to individual Connections; they are not global resources. To figure out a size
	for <tt>maxStatements</tt> that does not "churn" cached statements, you need to consider the number of <i>frequently used</i> 
	PreparedStatements in your application,	and multiply that by the number of Connections you expect in the pool (<tt>maxPoolSize</tt>
	in a busy application).
      </p>
      <p>
	<tt>maxStatementsPerConnection</tt> is a non-standard configuration parameter that makes a bit more
	sense conceptually. It defines how many statements each pooled <tt>Connection</tt> is allowed to own.
	You can set this to a bit more than the number of <tt>PreparedStatements</tt> your application <i>frequently</i>
	uses, to avoid churning.
      </p>
      <p>
	If either of these parameters are greater than zero, statement pooling will be enabled. If both
	parameters are greater than zero, both limits will be enforced. If only one is greater than zero, statement pooling
	will be enabled, but only one limit will be enforced.
      </p>
    </div>
    <h2><a name="performance">Performance</a></h2>
    <div class="sectiontext">
      <p>
	Enhanced performance is the purpose of <tt>Connection</tt> and <tt>Statement</tt> pooling, and a
	major goal of the c3p0 library. For most applications, <tt>Connection</tt> pooling
	will provide a significant performance gain, especially if you are acquiring
	an unpooled <tt>Connection</tt> for each client <tt>Thread</tt>. If you are letting a single,
	shared <tt>Connection</tt> serve many clients to avoid <tt>Connection</tt> acquisition overhead, 
	you may suffer performance issues and problems managing transactions when 
	your <tt>Connection</tt> is under concurrent load; <tt>Connection</tt> pooling will enable you 
	to switch to a one <tt>Connection</tt>-per-client-thread model with little or no cost. 
	If you are writing Enterprise Java Beans, you may be tempted to acquire a 
	<tt>Connection</tt> once and not return it until the bean is about to be destroyed or
	passivated. But this can be resource-costly, as dormant pooled 
	beans needlessly hold the <tt>Connection</tt>'s network and database resources. 
	<tt>Connection</tt> pooling permits beans to only "own" 
	a <tt>Connection</tt> while they are using it.  
      </p>
      <p>
	But, there are performance costs to c3p0 as well. In order to implement 
	automatic cleanup of unclosed <tt>ResultSets</tt> and <tt>Statements</tt> when parent resources 
	are returned to pools, all client-visible <tt>Connections</tt>, <tt>ResultSets</tt>, <tt>Statements</tt> 
	are really wrappers around objects provided by an underlying unpooled <tt>DataSource</tt> 
	or "traditional" JDBC driver. Thus, there is some extra overhead to all JDBC calls.
      </p>
      <p>
	Some attention has been paid to minimizing the "wrapper" overhead of c3p0. In
	my environment, the wrapper overhead amounts from several hundreths to several
	thousandths of the cost of <tt>Connection</tt> acquisition, so unless you are making
	many, many JDBC calls in fast succession, there will be a net 
	gain in performance and resource-utilization efficiency. 
	Significantly, the overhead associated with ResultSet operations (where
	one might iterate through a table with thousands of records) appears to be 
	negligibly small.
      </p>
    </div>
    <h2><a name="known_shortcomings">Known Shortcomings</a></h2>
    <div class="sectiontext">
      <ul>
	<li>
	  <p>
	    <tt>Connection</tt>s and <tt>Statement</tt>s are pooled on a per-authentication basis.
	    So, if one pool-backed <tt>DataSource</tt> is used to acquire <tt>Connection</tt>s both
	    for [<tt>user</tt>=alice, <tt>password</tt>=secret1] and [<tt>user</tt>=bob, <tt>password</tt>=secret2],
	    there will be two distinct pools, and the <tt>DataSource</tt> might in the
	    worst case manage twice the number of <tt>Connection</tt>s specified by the
	    <tt>maxPoolSize</tt> property.
	  </p>
	</li>
	<li>
	  <p>
	    The overhead of <tt>Statement</tt> pooling is too high. For drivers that
	    do not perform significant preprocessing of <tt>PreparedStatement</tt>s, the
	    pooling overhead outweighs any savings. <tt>Statement</tt> pooling is thus
	    turned off by default. If your driver does preprocess <tt>PreparedStatements</tt>,
	    especially if it does so via IPC with the RDBMS, you will probably
	    see a significant performance gain by turning <tt>Statement</tt> pooling on. (Do this by
	    defining a value for the configuration property <tt>maxStatements</tt> greater than zero.).
	  </p>
	</li>
      </ul>
    </div>
    <h2><a name="feedback_and_support">Feedback and Support</a></h2>
    <div class="sectiontext">
      <p>
	Please provide any and all feedback to &lt;<a href="mailto:swaldman@mchange.com">swaldman@mchange.com</a>&gt! 
	Also, feel free to join and ask questions on the <tt>c3p0-users</tt> mailing list.
	Sign up at <a href="http://sourceforge.net/projects/c3p0/">http://sourceforge.net/projects/c3p0/</a>
      </p>
      <p>  
	Thank you for using c3p0!!!
      </p>
    </div>
    <h2><a name="appendix_a">Appendix A: Configuration Properties</a></h2>
    <div class="sectiontext">
      <dl class="properties">
	<dt><a name="initialPoolSize"/>initialPoolSize</dt>
	<dd>
	  <div class="default">Default: 3</div>
	</dd>
	<dt><a name="minPoolSize"/>minPoolSize</dt>
	<dd>
	  <div class="default">Default: 3</div>
	</dd>
	<dt><a name="maxPoolSize"/>maxPoolSize</dt>
	<dd>
	  <div class="default">Default: 15</div>
	</dd>
	<dt><a name="idleConnectionTestPeriod"/>idleConnectionTestPeriod</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    If this is a number greater than 0, c3p0 will test all idle, pooled but unchecked-out connections, every this number of seconds.
	  </div>
	</dd>
	<dt><a name="maxIdleTime" />maxIdleTime</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    Seconds a Connection can remain pooled but unused before being discarded. Zero means idle connections never expire.
	  </div>
	</dd>
	<dt><a name="maxStatements" />maxStatements</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    The size of c3p0's global PreparedStatement cache. If both <tt>maxStatements</tt> and <tt>maxStatementsPerConnection</tt>
	    are zero, statement caching will not be enabled. If <tt>maxStatements</tt> is zero but <tt>maxStatementsPerConnection</tt>
	    is a non-zero value, statement caching will be enabled, but no global limit will be enforced, only the per-connection maximum.
	    <tt>maxStatements</tt> controls the total number of Statements cached,
	    for all Connections. If set, it should be a fairly large number, as each pooled Connection requires its own,
	    distinct flock of cached statements. As a guide, consider how many distinct PreparedStatements are used
	    <i>frequently</i> in your application, and multiply that number by <tt>maxPoolSize</tt> to arrive at an appropriate
	    value. Though <tt>maxStatements</tt> is the JDBC standard parameter for controlling statement caching, users may
	    find c3p0's alternative <tt>maxStatementsPerConnection</tt> more intuitive to use.
	  </div>
	</dd>
	<dt><a name="maxStatementsPerConnection" />maxStatementsPerConnection</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    The number of PreparedStatements c3p0 will cache for a single pooled Connection. 
	    If both <tt>maxStatements</tt> and <tt>maxStatementsPerConnection</tt>
	    are zero, statement caching will not be enabled. If <tt>maxStatementsPerConnection</tt> is zero but <tt>maxStatements</tt>
	    is a non-zero value, statement caching will be enabled, and a global limit enforced, but otherwise no limit will be set 
	    on the number of cached statements for a single Connection.
	    If set, maxStatementsPerConnection should be set to about the number distinct PreparedStatements that are used
	    <i>frequently</i> in your application, plus two or three extra so infrequently statements don't force the more common
	    cached statements to be culled. Though <tt>maxStatements</tt> is the JDBC standard parameter for controlling statement caching,
	    users may find <tt>maxStatementsPerConnection</tt> more intuitive to use.
	  </div>
	</dd>
	<dt><a name="propertyCycle" />propertyCycle</dt>
	<dd>
	  <div class="default">Default: 300</div>
	  <div class="propdesc">
	    Maximum time in seconds before user configuration constraints are enforced.
            c3p0 enforces configuration constraints continually, and ignores this parameter.
            It is included for JDBC 3 completeness.
	  </div>
	</dd>
	<dt><a name="checkoutTimeout" />checkoutTimeout</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    The number of milliseconds a client calling getConnection() will wait for a Connection to be checked-in or acquired
	    when the pool is exhausted. Zero means wait indefinitely. Setting any positive value will cause the getConnection()
	    call to time-out and break with an <tt>SQLException</tt> after the specified number of milliseconds.
	  </div>
	</dd>
	<dt><a name="acquireIncrement" />acquireIncrement</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    Determines how many connections at a time c3p0 will try to acquire when the pool is exhausted.
	  </div>
	</dd>
	<dt><a name="acquireRetryAttempts" />acquireRetryAttempts</dt>
	<dd>
	  <div class="default">Default: 30</div>
	  <div class="propdesc">
	    Defines how many times c3p0 will try to acquire a new Connection from the database before giving up. If
	    this value is less than or equal to zero, c3p0 will keep trying to fetch a Connection indefinitely.	  
	  </div>
	</dd>
	<dt><a name="acquireRetryDelay" />acquireRetryDelay</dt>
	<dd>
	  <div class="default">Default: 1000</div>
	  <div class="propdesc">
	    Milliseconds, time c3p0 will wait between acquire attempts.
	  </div>
	</dd>
	<dt><a name="breakAfterAcquireFailure" />breakAfterAcquireFailure</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    If true, a pooled DataSource will declare itself broken and be permanently closeed if
	    a Connection cannot be obtained from the database after making <tt>acquireRetryAttempts</tt> to acquire one.
	    If false, failure to obtain a Connection will cause all Threads waiting for the pool to acquire a Connection
	    to throw an Exception, but the DataSource will remain valid, and will attempt to acquire again following
	    a call to <tt>getConnection()</tt>.
	  </div>
	</dd>
	<dt><a name="testConnectionOnCheckout" />testConnectionOnCheckout</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    <b><i>Use only if necessary. Expensive.</i></b>
            If true, an operation will be performed at every connection checkout to verify that the connection is valid.
            <b>Better choice:</b> verify connections periodically using <tt>idleConnectionTestPeriod</tt>. Also, setting an
	    <tt>automaticTestTable</tt> or <tt>preferredTestQuery</tt> will usually speed up all connection tests.
	  </div>
	</dd>
	<dt><a name="testConnectionOnCheckin" />testConnectionOnCheckin</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
            If true, an operation will be performed asynchronously at every connection checkin to verify that the connection is valid.
	    Use in combination with <tt>idleConnectionTestPeriod</tt> for quite reliable, always asynchronous Connection testing.
	    Also, setting an <tt>automaticTestTable</tt> or <tt>preferredTestQuery</tt> will usually speed up all connection tests.
	  </div>
	</dd>
	<dt><a name="preferredTestQuery" />preferredTestQuery</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    Defines the query that will be executed for all connection tests, if the default ConnectionTester (or some
	    other implementation of <a href="apidocs/com/mchange/v2/c3p0/advanced/QueryConnectionTester.html">QueryConnectionTester</a>) 
	    is being used. Defining a <tt>preferredTestQuery</tt>
	    that will execute quickly in your database may dramatically speed up Connection tests. (If no <tt>preferredTestQuery</tt>
	    is set, the default ConnectionTester executes a <tt>getTables()</tt> call on the Connection's DatabaseMetaData.
	    Depending on your database, this may execute more slowly than a "normal" database query.) > <b>NOTE: The table against
            which your <tt>preferredTestQuery</tt> will be run must exist in the database schema <i>prior</i> to your initialization
            of your DataSource. If your application defines its own schema, try <tt>automaticTestTable</tt> instead.</b>
	  </div>
	</dd>
	<dt><a name="automaticTestTable" />automaticTestTable</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    If provided, c3p0 will create an empty table of the specified name, and use queries against that table to
	    test the Connection. If <tt>automaticTestTable</tt> is provided, c3p0 will generate its own test query, therefore
	    any <tt>preferredTestQuery</tt> set will be ignored. You should not work with the named table after c3p0 creates
	    it; it should be strictly for c3p0's use in testing your Connection. (If you define your own ConnectionTester, it
	    must implement the <a href="apidocs/com/mchange/v2/c3p0/advanced/QueryConnectionTester.html">QueryConnectionTester</a>
	    interface for this parameter to be useful.)
	  </div>
	</dd>
	<dt><a name="autoCommitOnClose" />autoCommitOnClose</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    The JDBC spec is unforgivably silent on what should happen to unresolved, pending
            transactions on Connection close. C3P0's default policy is to rollback any uncommitted, pending
            work. (I think this is absolutely, undeniably the right policy, but there is no consensus among JDBC driver vendors.) 
            Setting <tt>autoCommitOnClose</tt> to true causes uncommitted pending work to be committed, rather than rolled
            back on Connection close. [<i>Note: Since the spec is absurdly unclear on this question, application authors who wish
              to avoid bugs and inconsistent behavior should ensure that all transactions are explicitly either committed or
              rolled-back before close is called.</i>]
	  </div>
	</dd>
	<dt><a name="forceIgnoreUnresolvedTransactions" />forceIgnoreUnresolvedTransactions</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    <b><i>Strongly disrecommended. Setting this to <tt>true</tt> may lead to subtle and bizarre bugs.</i></b>
            This is a terrible setting, leave it alone unless absolutely necessary. It is here to workaround
            broken databases / JDBC drivers that do not properly support transactions, but that allow Connections'
            <tt>autoCommit</tt> flags to go to false regardless. If you are using a database that supports transactions
            "partially" (this is oxymoronic, as the whole point of transactions is to perform operations reliably and
            completely, but nonetheless such databases are out there), if you feel comfortable ignoring the fact that Connections
            with <tt>autoCommit == false</tt> may be in the middle of transactions and may hold locks and other resources,
            you may turn off c3p0's wise default behavior, which is to protect itself, as well as the usability and consistency
            of the database, by either rolling back (default) or committing (see <tt>c3p0.autoCommitOnClose</tt> <i>above</i>)
            unresolved transactions. <b>This should only be set to true when you are sure you are using a database that
              allows Connections' autoCommit flag to go to false, but offers no other meaningful support of transactions. Otherwise
              setting this to true is just a bad idea.</b>	
	  </div>
	</dd>
	<dt><a name="numHelperThreads" />numHelperThreads</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    c3p0 is very asynchronous. Slow JDBC operations are generally 
            performed by helper threads that don't hold contended locks. Spreading
            these operations over multiple threads can significantly improve performance
            by allowing multiple operations to be performed simultaneously.	
	  </div>
	</dd>
	<dt><a name="usesTraditionalReflectiveProxies" />usesTraditionalReflectiveProxies</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    c3p0 is very asynchronous. Slow JDBC operations are generally 
            performed by helper threads that don't hold contended locks. Spreading
            these operations over multiple threads can significantly improve performance
            by allowing multiple operations to be performed simultaneously.
 	  </div>
	</dd>
	<dt><a name="factoryClassLocation" />factoryClassLocation</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    DataSources that will be bound by JNDI and use that API's Referenceable interface
            to store themselves may specify a URL from which the class capable of dereferencing 
            a them may be loaded. If (as is usually the case) the c3p0 libraries will be locally
            available to the JNDI service, leave this set as null.	
	  </div>
	</dd>
      </dl>
    </div>
    <h2><a name="appendix_b">Appendix B: Configuring c3p0 DataSources in Tomcat</a></h2>
    <div class="sectiontext">
      <p>
	You can easily configure Apache's Tomcat web application server to use c3p0 pooled <tt>DataSource</tt>s. 
	Below is a sample config to get you started. It's a fragment of Tomcat's <tt>conf/server.xml</tt> file,
	which should be modified to suit and placed inside a <tt>&lt;Context&gt;</tt> element.
      </p>
      <div class="example">
&lt;Resource name="jdbc/pooledDS" auth="Container" type="com.mchange.v2.c3p0.ComboPooledDataSource" /&gt;
&lt;ResourceParams name="jdbc/pooledDS"&gt;
  &lt;parameter&gt;
    &lt;name&gt;factory&lt;/name&gt;
    &lt;value&gt;org.apache.naming.factory.BeanFactory&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;driverClass&lt;/name&gt;
    &lt;value&gt;org.postgresql.Driver&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;jdbcUrl&lt;/name&gt;
    &lt;value&gt;jdbc:postgresql://localhost/c3p0-test&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;user&lt;/name&gt;
    &lt;value&gt;swaldman&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;password&lt;/name&gt;
    &lt;value&gt;test&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;minPoolSize&lt;/name&gt;
    &lt;value&gt;5&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;maxPoolSize&lt;/name&gt;
    &lt;value&gt;15&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;acquireIncrement&lt;/name&gt;
    &lt;value&gt;5&lt;/value&gt;
  &lt;/parameter&gt;
&lt;/ResourceParams&gt;
      </div>
      <p>
	The rest is standard J2EE stuff: You'll need to declare your <tt>DataSource</tt> reference in your <tt>web.xml</tt>
	file:
      </p>
	
      <div class="example">
&lt;resource-ref&gt;
  &lt;res-ref-name&gt;jdbc/pooledDS&lt;/res-ref-name&gt;
  &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
  &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;
      </div>
      <p>      
	And you can access your <tt>DataSource</tt> from code within your web application like this:
      </p>
      <div class="example">
InitialContext ic = new InitialContext();
DataSource ds = (DataSource) ic.lookup("java:comp/env/jdbc/pooledDS");
      </div>
      <p>
	That's it!
      </p>
    </div>
    <hr/>
    <h2><a name="appendix_c">Appendix C: Oracle-specific API: createTemporaryBLOB() and createTemporaryCLOB()</a></h2>
    <div class="sectiontext">
      <p>
	The Oracle thin JDBC driver provides a non-standard API for creating temporary BLOBs and CLOBs that
	requires users to call methods on the raw, Oracle-specific Connection implementation. Advanced users
	might use the <a href="#raw_connection_ops">raw connection operations</a> described above to access this
	functionality, but a convenience class is available in a separate jar file (<tt>c3p0-oracle-thin-extras-@c3p0.version@.jar</tt>)
	for easier access to this functionality. Please see the 
	<a href="apidocs-oracle-thin/index.html">API docs for <tt>com.mchange.v2.c3p0.dbms.OracleUtils</tt></a>
	for details.
      </p>
    </div>
    <hr/>
    <a href="#contents">Back to Contents</a>
  </body>
</html>
