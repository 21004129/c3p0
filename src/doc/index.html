<html>
  <head>
    <title>c3p0 - JDBC3 Connection and Statement Pooling - Documentation</title>
    <style type="text/css">
      body {
         font-family: optima, helvetica, arial, sans-serif;
      }
      dl.properties {
         padding: 0em 3em 0em 3em;
      }
      dl.properties dd {
         padding-bottom: 0.5em;
         font-size: smaller;
      }
      dl.properties dt {
         padding-top: 1em;
         border-top: 1 dashed black;
         font-family: monospace;
	 color: red;
      }
      dl.properties div.default {
         padding-top: 0.5em;
         text-decoration: underline;
         padding-bottom: 0.5em;
      }
      div.example {
         white-space: pre;
         font-family: monospace;
	 font-size: smaller;
	 background-color: #CCCCFF;
         margin: 3em 3em 3em 3em;
         padding: 1em 0em 1em 2em;
         border-top: 2 solid black;
         border-bottom: 2 solid black;
      }
      div.example_properties {
         white-space: pre;
         font-family: monospace;
	 font-size: smaller;
	 background-color: #CCCCFF;
         margin: 3em 3em 3em 3em;
         padding: 1em 0em 1em 0em;
         border-top: 2 solid black;
         border-bottom: 2 solid black;
      }
      div.example_properties strong {
         font-weight: bold;
	 color: red;
      }
      div.sectiontext {
         margin-left: 1em;
      }
      div.subtitle {
	 font-size: 12pt;
	 background-color: #FFFFFF;
      }
      div.top_boilerplate {
         margin-left: 8em;
         margin-right: 8em;
      }

      h1 {
         text-align: center;
	 background-color: #FFCCAA;
      }
      h2 {
	 background-color: #FFFFAA;
         border-bottom: 2 solid black;
         margin-top: 2em;
      }
      ol.contents ol {
         list-style-type: lower-roman;
      }
      ol.contents ol li {
	 font-size: smaller;
      }

    </style>
  </head>
  <body>
    <h1>
      <div>c3p0 - JDBC3 Connection and Statement Pooling</div>
      <div class="subtitle">version @c3p0.version@</div>
    </h1>
    <div class="top_boilerplate">
      <p>by Steve Waldman &lt;<a href="mailto:swaldman@mchange.com">swaldman@mchange.com</a>&gt;</p>
      <p>&copy; 2003 Machinery For Change, Inc.</p>
      <p><i>
	  This software is made available for use, modification, and redistribution,
	  under the terms of the <a href="../LICENSE">Lesser GNU Public License (LGPL)</a>, which you should
	  have received with this distribution.
      </i></p>
      <p><b>Note:</b> <i>API docs for c3p0 can be found <a href="apidocs/">here</a>.</i></p>
    </div>
    <hr/>
    <h2><a name="contents">Contents</a></h2>
    <ol class="contents">
      <li><a href="#contents">Contents</a></li>
      <li><a href="#quickstart">Quickstart</a></li>
      <li><a href="#what_is">What is c3p0?</a></li>
      <li><a href="#prerequisites">Prerequisites</a></li>
      <li><a href="#installation">Installation</a></li>
      <li>
	<a href="#using_c3p0">Using c3p0</a>
	<ol>
	  <li><a href="#using_combopooleddatasource">Using ComboPooledDataSource</a></li>
	  <li><a href="#using_datasources_factory">Using the DataSouces factory class</a></li>
	  <li><a href="#querying">Querying Pool Status</a></li>
	  <li><a href="#cleaning">Cleaning Up Pool Resources</a></li>
	  <li><a href="#build_your_own">Advanced: Building Your Own PoolBackedDataSource</a></li>
	</ol>
      </li>
      <li>
	<a href="#configuration">Configuration</a>
	<ol>
	  <li><a href="c3p0_properties">Overriding c3p0 defaults with a c3p0.properties file</a></li>
	  <li><a href="programmatic_configuration">Programmatic configuration of DataSources</a></li>
	</ol>
      </li>
      <li><a href="#known_shortcomings">Performance</a></li>
      <li><a href="#known_shortcomings">Known shortcomings</a></li>
      <li><a href="#feedback_and_support">Feedback and support</a></li>
      <li><a href="#appendix_a">Appendix A: Configuration Properties</a></li>
      <li><a href="#appendix_b">Appendix B: Configuring c3p0 pooled DataSources for Apache Tomcat</a></li>
      <li><a href="apidocs/index.html">API Documentation</a></li>
    </ol>
    <hr/>
    <h2><a name="quickstart">Quickstart</a></h2>
    <div class="sectiontext">
      <p>
	c3p0 was designed to be butt-simple to use. Just put
	the jar file [<tt>lib/c3p0-0.8.x.jar</tt>] in your applications
	effective <tt>CLASSPATH</tt>, and make a <tt>DataSource</tt> like this:
      </p>
      <div class="example">
import com.mchange.v2.c3p0.*;
	
...
	
ComboPooledDataSource cpds = new ComboPooledDataSource();
cpds.setDriverClass( "org.postgresql.Driver" ); //loads the jdbc driver            
cpds.setJdbcUrl( "jdbc:postgresql://localhost/testdb" );
cpds.setUser("dbuser");                                  
cpds.setPassword("dbpassword");                                  
      </div>
      <p>
	<b>[Optional]</b> If you want to turn on PreparedStatement pooling, you must also set <tt>maxStatements</tt> (which defaults to 0):
      </p>
      <div class="example">
cpds.setMaxStatements( 180 );                                  
      </div>
      <p>
	Do whatever you want with your <tt>DataSource</tt>, which will be backed
	by a <tt>Connection</tt> pool set up with default parameters. You
	can bind the <tt>DataSource</tt> to a JNDI name service, or use it
	directly, as you prefer.
      </p>
      <p>
	When you are done, you can clean up the <tt>DataSource</tt> you've created
	like this:
      </p>
      <div class="example">
DataSources.destroy( cpds );
      </div>
      <p>
	That's it! The rest is detail.
      </p>
    </div>
    <h2><a name="basics">What is c3p0?</a></h2>
    <div class="sectiontext">
      <p>
	c3p0 is an easy-to-use library for making traditional JDBC drivers 
	"enterprise-ready" by augmenting them with functionality defined by 
	the jdbc3 spec and the optional extensions to jdbc2. In particular, 
	c3p0 provides several useful services:
      </p>
      <ul>
	<li>
	  Classes which adapt traditional DriverManager-based JDBC
	  drivers to the new <tt>javax.sql.DataSource</tt> scheme for acquiring
	  database <tt>Connection</tt>s.
	</li>
	<li>
	  Transparent pooling of <tt>Connection</tt> and <tt>PreparedStatement</tt>s
	  behind <tt>DataSource</tt>s which can "wrap" around traditional
	  drivers or arbitrary unpooled <tt>DataSource</tt>s.
	</li>
      </ul>
      <p>
	The library tries hard to get the details right:
      </p>
      <ul>
	<li>
	  c3p0 <tt>DataSource</tt>s are both <tt>Referenceable</tt> and <tt>Serializable</tt>, and are thus
	  suitable for binding to a wide-variety of JNDI-based naming services.
	</li>
	<li>
	  <tt>Statement</tt> and <tt>ResultSet</tt>s are carefully cleaned up when pooled
	  <tt>Connection</tt>s and <tt>Statement</tt>s are checked in, to prevent resource-
	  exhaustion when clients use the lazy but common resource-management
	  strategy of only cleaning up their <tt>Connection</tt>s....
	</li>
	<li>
	  The library adopts the approach and uses the internal interfaces
	  defined by the JDBC 2 and 3 specification (even where these
	  conflict with the library author's preferences). <tt>DataSource</tt>s
	  are written in the JavaBean style, offering all the required and
	  most of the optional properties (as well as some non-standard ones),
	  and no-arg constructors.
	</li>
      </ul>
      <p>
	c3p0 hopes to provide <tt>DataSource</tt> implementations more than suitable for 
	use by high-volume "J2EE enterprise applications". Please provide feedback, bug-fixes, etc.!
      </p>
    </div>
    <h2><a name="prerequisites">Prerequisites</a></h2>
    <div class="sectiontext">
      <p>
	c3p0 requires a level 1.3.x or above Java Runtime Environment, and
	the JDBC 2.x or above javax.sql libraries. c3p0 works fine under
	Java 1.4.x.
      </p>
    </div>
    <h2><a name="installation">Installation</a></h2>
    <div class="sectiontext">
      <p>
	Put the file <tt>lib/c3p0-0.8.x.jar</tt> required libraries
	somewhere in your CLASSPATH (or any other place where your application's
	classloader will find it). That's it!
      </p>
    </div>
    <h2><a name="using c3p0">Using c3p0</a></h2>
    <div class="sectiontext">
      <p>
	From a users' perspective, c3p0 simply provides standard jdbc2 <tt>DataSource</tt>
	objects. When creating these <tt>DataSource</tt>s, users can control pooling-related, 
	naming-related, and other properties (See <a href="#appendix_a">Appendix A</a>). All pooling is entirely
	transparent to users once a <tt>DataSource</tt> has been created.
      </p>
      <p>
	There are three ways of acquiring c3p0 pool-backed <tt>DataSource</tt>s: 1) directly instantiate and configure a 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a> bean; 
	2) use the <tt>DataSource</tt>s factory class; or 3) "build your own" pool-backed
	<tt>DataSource</tt> by directly instantiating <tt>PoolBackedDataSource</tt> and setting its <tt>ConectionPoolDataSource</tt>. Most
	users will probably find instantiating <a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a>
	to be the most convenient approach. Once instantiated,
	c3p0 <tt>DataSource</tt>s can be bound to nearly any JNDI-compliant name service.
      </p>
      <p>
	Regardless of how you create your <tt>DataSource</tt>, c3p0 will use defaults for any configuration parameters that
	you do not specify programmatically. c3p0 has built-in, hard-coded defaults, but you can override these by creating
	a file called <tt>c3p0.properties</tt> and storing it as a top-level resource in the same <tt>CLASSPATH</tt> / classloader
	that loads c3p0's jar file. (See <a href="#configuration">Configuration</a> below.)
      </p>
      <a name="using_combopooleddatasource">
	<h3>Instantiating and Configuring a ComboPooledDataSource</h3>
      </a>
      <p>
	Perhaps the most straightforward way to create a c3p0 pooling <tt>DataSource</tt> is to instantiate an instance of 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>com.mchange.v2.c3p0.ComboPooledDataSource</tt></a>. 
	This is a JavaBean-style class with a public, no-arg constructor,
	but before you use the <tt>DataSource</tt>, you'll have to be sure to set at least the property <tt>jdbcUrl</tt>. You may also
	want to set <tt>user</tt> and <tt>password</tt>, and if you have not externally preloaded the old-style JDBC driver you'll
	use you should set the <tt>driverClass</tt>.
      </p>
      <div class="example">
ComboPooledDataSource cpds = new ComboPooledDataSource();
cpds.setDriverClass( "org.postgresql.Driver" ); //loads the jdbc driver            
cpds.setJdbcUrl( "jdbc:postgresql://localhost/testdb" );
cpds.setUser("swaldman");                                  
cpds.setPassword("test-password");                                  
	
// the settings below are optional -- c3p0 can work with defaults
cpds.setMinPoolSize(5);                                     
cpds.setAcquireIncrement(5);
cpds.setMaxPoolSize(20);
	
// The DataSource cpds is now a fully configured and usable pooled DataSource
	
...
      </div>
      <a name="using_datasources_factory">
	<h3>Using the DataSources factory class</h3>
      </a>
      <p>
	Alternatively, you can use the static factory class 
	<a href="apidocs/com/mchange/v2/c3p0/DataSources.html"><tt>com.mchange.v2.c3p0.DataSources</tt></a> to build unpooled <tt>DataSource</tt>s 
	from traditional JDBC drivers, and to build pooled <tt>DataSource</tt>s from unpooled <tt>DataSource</tt>s:
      </p>
      <div class="example">
DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                        "swaldman", 
                                                        "test-password");
DataSource ds_pooled = DataSources.pooledDataSource( ds_unpooled );

// The DataSource ds_pooled is now a fully configured and usable pooled DataSource.
// The DataSource is using a default pool configuration, and Postgres' JDBC driver
// is presumed to have already been loaded via the jdbc.drivers system property or an
// explicit call to Class.forName("org.postgresql.Driver") elsewhere.
	
...
      </div>
      <p>
	If you use the <a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>
	factory class, and you want to programmatically override default configuration
	parameters, make use of the <a href="apidocs/com/mchange/v2/c3p0/PoolConfig.html"><tt>PoolConfig</tt></a> class:
      </p>
      <div class="example">
DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                        "swaldman", 
                                                        "test-password");
							      
PoolConfig pc = new PoolConfig();
pc.setMaxStatements(200);  //turn on Statement pooling

// pass our overriding PoolConfig to the DataSources.pooledDataSource() factory method.

ds_pooled = DataSources.pooledDataSource( ds_unpooled, pc ); 

// The DataSource ds_pooled is now a fully configured and usable pooled DataSource,
// with Statement caching enabled for a maximum of up to 200 statements.

...
      </div>
      <a name="querying">
	<h3>Querying a PooledDataSource's current status</h3>
      </a>
      <p>
	c3p0 <tt>DataSource</tt>s backed by a pool, which include implementations of 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a> and
	the objects returned by <tt><a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.pooledDataSource( ... )</tt>, 
	all implement the interface
	<a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>com.mchange.v2.c3p0.PooledDataSource</tt></a>, 
	which makes available a number of methods for querying the status of
	<tt>DataSource Connection</tt> pools. Below is sample code that queries a <tt>DataSource</tt> for its 
	status:
      </p>
      <div class="example">
// fetch a JNDI-bound DataSource
InitialContext ictx = new InitialContext();
DataSource ds = (DataSource) ictx.lookup( "java:comp/env/jdbc/myDataSource" );

// make sure it's a c3p0 PooledDataSource
if ( ds instanceof PooledDataSource)
{
  PooledDataSource pds = (PooledDataSource) ds;
  System.err.println("num_connections: "      + pds.getNumConnections());
  System.err.println("num_busy_connections: " + pds.getNumBusyConnections());
  System.err.println("num_idle_connections: " + pds.getNumIdleConnections());
  System.err.println();
}
else
  System.err.println("Not a c3p0 PooledDataSource!");
      </div>
      <p>
	The status querying methods all come in two overloaded forms, such as:
      </p>
      <ul>
	<li><tt>public int getNumConnections()</tt></li>
	<li><tt>public int getNumConnections(String username, String password)</tt></li>
      </ul>
      <p>
	The version with arguments is necessary in case clients have retrieved <tt>Connection</tt>s from
	the <tt>DataSource</tt> using an explicit username and password 
	[i.e. by calling <tt>myDataSource.getConnection("myname", "mypassword")</tt>] 
	rather than using the <tt>DataSource</tt>'s default authentication, which is defined by the JavaBean properties
	<tt>user</tt> and <tt>password</tt>, and used in calls to <tt>myDataSource.getConnection()</tt> with no arguments. 
	c3p0 maintains separate pools for Connections with distinct
	authentications, and you can query the status of those pools individually. 
      </p>
      <p>
	<i>
	  Most users acquire default-authenticated Connections from <tt>DataSource</tt>s, and
	  and can thus rely on the default, no-arg versions of the status-querying methods.
	</i>
      </p>
      <a name="cleaning">
	<h3>Cleaning up after c3p0 PooledDataSources</h3>
      </a>
      <p>
	The easy way to clean up after c3p0-created <tt>DataSource</tt>s is to use the static destroy method
	defined by the class <a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>. Only 
	<a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>s 
	need to be cleaned up, but 
	<a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.destroy( ... ) does no harm if it is called on an unpooled or non-c3p0
	DataSource.
      </p>
      <div class="example">
DataSource ds_pooled   = null;
	
try
{
  DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                          "swaldman", 
                                                          "test-password");
  ds_pooled = DataSources.pooledDataSource( ds_unpooled );

  // do all kinds of stuff with that sweet pooled DataSource...
}
finally
{
  DataSources.destroy( ds_pooled );
}
      </div>
      <p>
	Alternatively, c3p0's <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	interface contains a <tt>close()</tt> method
	that you can call when you know you are finished with a DataSource. So, you can cast a c3p0
	derived <tt>DataSource</tt> to a <tt>PooledDataSource</tt> and close it:
      </p>
      <div class="example">
static void cleanup(DataSource ds) throws SQLException
{
  // make sure it's a c3p0 PooledDataSource
  if ( ds instanceof PooledDataSource)
  {
    PooledDataSource pds = (PooledDataSource) ds;
    pds.close();
  }     
  else
    System.err.println("Not a c3p0 PooledDataSource!");
}
      </div>
      <p>
	Regardless of which method you use, closing or destroying a <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	does not necessarily shut down the underlying pools. It is possible for several 
	<tt>DataSource</tt> instances to share the same <tt>Connection</tt> and <tt>Statement</tt> pools. Calling
	<tt>close()</tt> or <tt>destroy()</tt> decrements a reference count, and the pools are actually
	shut down only when the reference count goes to zero. If you are careful to close()
	all your <tt>DataSource</tt> instances, you can reliably clean up all of c3p0's pooled 
	<tt>Connection</tt>s and helper threads.
      </p>
      <p>
	Unreferenced instances of <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	that are not <tt>close()</tt>ed by clients
	<tt>close()</tt> themselves prior to garbage collection in their <tt>finalize()</tt> methods. 
	As always, finalization should be considered
	a backstop and not a prompt or sure approach to resource cleanup.
      </p>
      <a name="build_your_own">
	<h3>Advanced: Building your own PoolBackedDataSource</h3>
      </a>
      <p>
	There is little reason for most programmers to do this, but you can build a pooling <tt>DataSource</tt> in a
	step-by-step way by instantiating and configuring an unpooled <tt>DriverManagerDataSource</tt>, instantiating a
	<tt>WrapperConnectionPoolDataSource</tt> and setting the unpooled <tt>DataSource</tt> as its <tt>nestedDataSource</tt> property,
	and then using that to set the <tt>connectionPoolDataSource</tt> property of a new <tt>PoolBackedDataSource</tt>.
      </p>
      <p>
	This sequence of events is primarily interesting if your driver offers an unpooled implementation of DataSource, and you'd
	like c3p0 to use that. Rather than using c3p0's <tt>DriverManagerDataSource</tt> implementation, you can substitute your
	vendor-supplied <tt>DataSource</tt> as the <tt>nestedDataSource</tt> for a <tt>WrapperConnectionPoolDataSource</tt>.
      </p>
      <h2><a name="configuration">Configuration</a></h2>
      <p>
	While c3p0 does not <i>require</i> very much configuration, it is very tweakable. All the interesting
	knobs and dials are represented as JavaBean properties. Following JavaBean conventions, we note that
	if an Object has a property of type <tt>T</tt> called <tt>foo</tt>, it will have methods that look
	like...
	<blockquote><tt>
	    public T getFoo();<br/>
	    public void setFoo(T foo);
	</tt></blockquote>
	...or both, depending upon whether the property is read-only, write-only, or read-writable.
      </p>
      <p>
	The tweakable properties, along with their definitions and default values, are described 
	in <a href="#appendix_a">Appendix A</a> below.
      </p>
      <p>
	There are two ways to modify c3p0 properties: You can override the defaults for your
	entire application, or you can programmatically alter the values associated with a
	particular <tt>DataSource</tt>.
      </p>
      <a name="c3p0_properties">
	<h3>Overriding c3p0 defaults via <tt>c3p0.properties</tt></h3>
      </a>
      <p>
	To override the library's built-in defaults, create a file called <tt>c3p0.properties</tt>
	and place it at the "root" of your classpath or classloader. For a typical standalone
	application, that means place the file in a directory named in your <tt>CLASSPATH</tt>
	environment variable. For a typical web-application, the file should be placed in 
	<tt>WEB-INF/classes</tt>. In general, the file must be available as a classloader
	resource under the name <tt>/c3p0.properties</tt>, in the classloader that loaded
	c3p0's jar file. Review the API docs (especilly <tt>getResource...</tt> methods) of 
	<tt>java.lang.Class</tt>, <tt>java.lang.ClassLoader</tt>, and <tt>java.util.ResourceBundle</tt> 
	if this is unfamiliar.
      </p>
      <p>
	The format of <tt>c3p0.properties</tt> should be a normal Java Properties file format,
	whose keys are c3p0 configurable properties. See <a href="#appendix_a">Appendix A</a>.
	for the specifics. An example <tt>c3p0.properties</tt> file is produced below:
      </p>
      <div class="example">
# turn on statement pooling
c3p0.maxStatements=150
	
# close pooled Connections that go unused for
# more than half an hour
c3p0.maxIdleTime=1800
      </div>
      <a name="programmatic_configuration">
	<h3>Programmatic configuration of individual <tt>DataSource</tt>s</h3>
      </a>
      <p>
	<tt>DataSource</tt>s are usually configured before they are used, either
	during or immediately following their construction. c3p0 does
	support property modifications midstream, however.
      </p>
      <p>
	If you obtain a <tt>DataSource</tt> by instantiating a 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a>, 
	configure it by simply calling appropriate setter methods offered by that class
	before attempting a call to <tt>getConnection()</tt>. See the example above.
      </p>
      <p>
	If you obtain a <tt>DataSource</tt> by using factory methods of
	the utility class <a href="apidocs/com/mchange/v2/c3p0/DataSources.html"><tt>com.mchange.v2.c3p0.DataSources</tt></a>,
	and wish to use a non-default configuration,
	you should first create a <a href="apidocs/com/mchange/v2/c3p0/PoolConfig.html"><tt>PoolConfig</tt></a> Object,
	call the appropriate property setters on that <a href="apidocs/com/mchange/v2/c3p0/PoolConfig.html"><tt>PoolConfig</tt></a>,
	and pass your configuration as an argument to 
	<tt><a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.pooledDataSource( ... )</tt>.
	See the example above.
      </p>
    </div>
    <h2><a name="performance">Performance</a></h2>
    <div class="sectiontext">
      <p>
	Enhanced performance is the purpose of <tt>Connection</tt> and <tt>Statement</tt> pooling, and a
	major goal of the c3p0 library. For most applications, <tt>Connection</tt> pooling
	will provide a significant performance gain, especially if you are acquiring
	an unpooled <tt>Connection</tt> for each client <tt>Thread</tt>. If you are letting a single,
	shared <tt>Connection</tt> serve many clients to avoid <tt>Connection</tt> acquisition overhead, 
	you may suffer performance issues and problems managing transactions when 
	your <tt>Connection</tt> is under concurrent load; <tt>Connection</tt> pooling will enable you 
	to switch to a one <tt>Connection</tt>-per-client-thread model with little or no cost. 
	If you are writing Enterprise Java Beans, you may be tempted to acquire a 
	<tt>Connection</tt> once and not return it until the bean is about to be destroyed or
	passivated. But this can be resource-costly, as dormant pooled 
	beans needlessly hold the <tt>Connection</tt>'s network and database resources. 
	<tt>Connection</tt> pooling permits beans to only "own" 
	a <tt>Connection</tt> while they are using it.  
      </p>
      <p>
	But, there are performance costs to c3p0 as well. In order to implement 
	automatic cleanup of unclosed <tt>ResultSets</tt> and <tt>Statements</tt> when parent resources 
	are returned to pools, all client-visible <tt>Connections</tt>, <tt>ResultSets</tt>, <tt>Statements</tt> 
	are really wrappers around objects provided by an underlying unpooled <tt>DataSource</tt> 
	or "traditional" JDBC driver. Thus, there is some extra overhead to all JDBC calls.
      </p>
      <p>
	Some attention has been paid to minimizing the "wrapper" overhead of c3p0. In
	my environment, the wrapper overhead amounts from several hundreths to several
	thousandths of the cost of <tt>Connection</tt> acquisition, so unless you are making
	many, many JDBC calls in fast succession, there will be a net 
	gain in performance and resource-utilization efficiency. 
	Significantly, the overhead associated with ResultSet operations (where
	one might iterate through a table with thousands of records) appears to be 
	negligibly small.
      </p>
    </div>
    <h2><a name="known_shortcomings">Known Shortcomings</a></h2>
    <div class="sectiontext">
      <ul>
	<li>
	  <p>
	    <tt>Connection</tt>s and <tt>Statement</tt>s are pooled on a per-authentication basis.
	    So, if one pool-backed <tt>DataSource</tt> is used to acquire <tt>Connection</tt>s both
	    for [<tt>user</tt>=alice, <tt>password</tt>=secret1] and [<tt>user</tt>=bob, <tt>password</tt>=secret2],
	    there will be two distinct pools, and the <tt>DataSource</tt> might in the
	    worst case manage twice the number of <tt>Connection</tt>s specified by the
	    <tt>maxPoolSize</tt> property.
	  </p>
	</li>
	<li>
	  <p>
	    The overhead of <tt>Statement</tt> pooling is too high. For drivers that
	    do not perform significant preprocessing of <tt>PreparedStatement</tt>s, the
	    pooling overhead outweighs any savings. <tt>Statement</tt> pooling is thus
	    turned off by default. If your driver does preprocess <tt>PreparedStatements</tt>,
	    especially if it does so via IPC with the RDBMS, you will probably
	    see a significant performance gain by turning <tt>Statement</tt> pooling on. (Do this by
	    defining a value for the configuration property <tt>maxStatements</tt> greater than zero.).
	  </p>
	</li>
      </ul>
    </div>
    <h2><a name="feedback_and_support">Feedback and Support</a></h2>
    <div class="sectiontext">
      <p>
	Please provide any and all feedback to &lt;<a href="mailto:swaldman@mchange.com">swaldman@mchange.com</a>&gt! 
	Also, feel free to join and ask questions on the <tt>c3p0-users</tt> mailing list.
	Sign up at <a href="http://sourceforge.net/projects/c3p0/">http://sourceforge.net/projects/c3p0/</a>
      </p>
      <p>  
	Thank you for using c3p0!!!
      </p>
    </div>
    <h2><a name="appendix_a">Appendix A: Configuration Properties</a></h2>
    <div class="sectiontext">
      <dl class="properties">
	<dt>initialPoolSize</dt>
	<dd>
	  <div class="default">Default: 3</div>
	</dd>
	<dt>minPoolSize</dt>
	<dd>
	  <div class="default">Default: 3</div>
	</dd>
	<dt>maxPoolSize</dt>
	<dd>
	  <div class="default">Default: 15</div>
	</dd>
	<dt>idleConnectionTestPeriod</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    If this is a number greater than 0, c3p0 will test all idle, pooled but unchecked-out connections, every this number of seconds.
	  </div>
	</dd>
	<dt>maxIdleTime</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    Seconds a Connection can remain pooled but unused before being discarded. Zero means idle connections never expire.
	  </div>
	</dd>
	<dt>maxStatements</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    The size of c3p0's PreparedStatement cache. Zero means statement caching is turned off.
	  </div>
	</dd>
	<dt>propertyCycle</dt>
	<dd>
	  <div class="default">Default: 300</div>
	  <div class="propdesc">
	    Maximum time in seconds before user configuration constraints are enforced.
            c3p0 enforces configuration constraints continually, and ignores this parameter.
            It is included for JDBC 3 completeness.
	  </div>
	</dd>
	<dt>acquireIncrement</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    Determines how many connections at a time c3p0 will try to acquire when the pool is exhausted.
	  </div>
	</dd>
	<dt>acquireRetryAttempts</dt>
	<dd>
	  <div class="default">Default: 30</div>
	  <div class="propdesc">
	    Defines how many times c3p0 will try to acquire a new Connection from the database before giving up. If
	    this value is less than or equal to zero, c3p0 will keep trying to fetch a Connection indefinitely.	  
	  </div>
	</dd>
	<dt>acquireRetryDelay</dt>
	<dd>
	  <div class="default">Default: 1000</div>
	  <div class="propdesc">
	    Milliseconds, time c3p0 will wait between acquire attempts.
	  </div>
	</dd>
	<dt>breakAfterAcquireFailure</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    If true, a pooled DataSource will declare itself broken and be permanently closeed if
	    a Connection cannot be obtained from the database after making <tt>acquireRetryAttempts</tt> to acquire one.
	    If false, failure to obtain a Connection will cause all Threads waiting for the pool to acquire a Connection
	    to throw an Exception, but the DataSource will remain valid, and will attempt to acquire again following
	    a call to <tt>getConnection()</tt>.
	  </div>
	</dd>
	<dt>testConnectionOnCheckout</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    <b><i>Use only if necessary. Very expensive.</i></b>
            If true, an operation will be performed at every connection checkout to verify that the connection is valid.
            <b>Better choice:</b> verify connections periodically using c3p0.idleConnectionTestPeriod	
	  </div>
	</dd>
	<dt>autoCommitOnClose</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    The JDBC spec is unforgivably silent on what should happen to unresolved, pending
            transactions on Connection close. C3P0's default policy is to rollback any uncommitted, pending
            work. (I think this is absolutely, undeniably the right policy, but there is no consensus among JDBC driver vendors.) 
            Setting <tt>autoCommitOnClose</tt> to true causes uncommitted pending work to be committed, rather than rolled
            back on Connection close. [<i>Note: Since the spec is absurdly unclear on this question, application authors who wish
              to avoid bugs and inconsistent behavior should ensure that all transactions are explicitly either committed or
              rolled-back before close is called.</i>]
	  </div>
	</dd>
	<dt>forceIgnoreUnresolvedTransactions</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    <b><i>Strongly disrecommended. Setting this to <tt>true</tt> may lead to subtle and bizarre bugs.</i></b>
            This is a terrible setting, leave it alone unless absolutely necessary. It is here to workaround
            broken databases / JDBC drivers that do not properly support transactions, but that allow Connections'
            <tt>autoCommit</tt> flags to go to false regardless. If you are using a database that supports transactions
            "partially" (this is oxymoronic, as the whole point of transactions is to perform operations reliably and
            completely, but nonetheless such databases are out there), if you feel comfortable ignoring the fact that Connections
            with <tt>autoCommit == false</tt> may be in the middle of transactions and may hold locks and other resources,
            you may turn off c3p0's wise default behavior, which is to protect itself, as well as the usability and consistency
            of the database, by either rolling back (default) or committing (see <tt>c3p0.autoCommitOnClose</tt> <i>above</i>)
            unresolved transactions. <b>This should only be set to true when you are sure you are using a database that
              allows Connections' autoCommit flag to go to false, but offers no other meaningful support of transactions. Otherwise
              setting this to true is just a bad idea.</b>	
	  </div>
	</dd>
	<dt>numHelperThreads</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    c3p0 is very asynchronous. Slow JDBC operations are generally 
            performed by helper threads that don't hold contended locks. Spreading
            these operations over multiple threads can significantly improve performance
            by allowing multiple operations to be performed simultaneously.	
	  </div>
	</dd>
	<dt>factoryClassLocation</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    DataSources that will be bound by JNDI and use that API's Referenceable interface
            to store themselves may specify a URL from which the class capable of dereferencing 
            a them may be loaded. If (as is usually the case) the c3p0 libraries will be locally
            available to the JNDI service, leave this set as null.	
	  </div>
	</dd>
      </dl>
    </div>
    <h2><a name="appendix_b">Appendix B: Configuring c3p0 DataSources in Tomcat</a></h2>
    <div class="sectiontext">
      <p>
	You can easily configure Apache's Tomcat web application server to use c3p0 pooled <tt>DataSource</tt>s. 
	Below is a sample config to get you started. It's a fragment of Tomcat's <tt>conf/server.xml</tt> file,
	which should be modified to suit and placed inside a <tt>&lt;Context&gt;</tt> element.
      </p>
      <div class="example">
&lt;Resource name="jdbc/pooledDS" auth="Container" type="com.mchange.v2.c3p0.ComboPooledDataSource" /&gt;
&lt;ResourceParams name="jdbc/pooledDS"&gt;
  &lt;parameter&gt;
    &lt;name&gt;factory&lt;/name&gt;
    &lt;value&gt;org.apache.naming.factory.BeanFactory&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;driverClass&lt;/name&gt;
    &lt;value&gt;org.postgresql.Driver&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;jdbcUrl&lt;/name&gt;
    &lt;value&gt;jdbc:postgresql://localhost/c3p0-test&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;user&lt;/name&gt;
    &lt;value&gt;swaldman&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;password&lt;/name&gt;
    &lt;value&gt;test&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;minPoolSize&lt;/name&gt;
    &lt;value&gt;5&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;maxPoolSize&lt;/name&gt;
    &lt;value&gt;15&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;acquireIncrement&lt;/name&gt;
    &lt;value&gt;5&lt;/value&gt;
  &lt;/parameter&gt;
&lt;/ResourceParams&gt;
      </div>
      <p>
	The rest is standard J2EE stuff: You'll need to declare your <tt>DataSource</tt> reference in your <tt>web.xml</tt>
	file:
      </p>
	
      <div class="example">
&lt;resource-ref&gt;
  &lt;res-ref-name&gt;jdbc/pooledDS&lt;/res-ref-name&gt;
  &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
  &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;
      </div>
      <p>      
	And you can access your <tt>DataSource</tt> from code within your web application like this:
      </p>
      <div class="example">
InitialContext ic = new InitialContext();
DataSource ds = (DataSource) ic.lookup("java:comp/env/jdbc/pooledDS");
      </div>
      <p>
	That's it!
      </p>
    </div>
    <hr/>
    <a href="#contents">Back to Contents</a>
  </body>
</html>
